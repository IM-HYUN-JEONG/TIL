## ì»¨íŠ¸ë™íŠ¸ êµ¬ì¡°

## Declare within Contract

- State Variables
- Functions
- Function Modifiers
- Events
- Struct Types
- Enum Types

1. State Variables

- ë¸”ë¡ì²´ì¸ì— ì˜êµ¬íˆ ì €ì¥í•  ê°’ë“¤ì€ ìƒíƒœë³€ìˆ˜(State Variables)ë¡œ ì„ ì–¸
  - ì–´ë–¤ ê°’ë“¤ì€ ë°˜ë“œì‹œ State Variablesë¡œ ì„ ì–¸ë˜ì–´ì•¼í•œë‹¤(mapping)
- publicí‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ë¥¼ ì™¸ë¶€ì— ë…¸ì¶œ ê°€ëŠ¥
  - â¡ï¸ ì´ ê²½ìš° ìë™ìœ¼ë¡œ í•´ë‹¹ ë³€ìˆ˜ ê°’ì„ ëŒë ¤ì£¼ëŠ” Getterí•¨ìˆ˜ê°€ ìƒì„±ë¨
- publicí‚¤ì›Œë“œë¡œ ì„ ì–¸ì´ ë˜ì–´ìˆëŠ” í•¨ìˆ˜ë§Œ ë‹¤ë¥¸ ì»¨íŠ¸ë™íŠ¸ê°€ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤

```
contract Count {
    uint public count = 0;
    address public lastParticipant;
}
```

2. Functions

- í•¨ìˆ˜ëŠ” ì‹¤í–‰ê°€ëŠ¥í•œ ì½”ë“œë¥¼ ì •ì˜í•œ ê²ƒ
  - external, public, internal, privateì¤‘ í•˜ë‚˜ë¡œ visibilityë¥¼ ì„¤ì • ê°€ëŠ¥
  - payable, view, pureë“± í•¨ìˆ˜ì˜ ìœ í˜•ì„ ì •ì˜ ê°€ëŠ¥

```
contract Count {
    function plus() public {
        count++;
        lastParticipant = msg.sender;
    }
}
```

3. Function Modifiers

- í•¨ìˆ˜ì˜ ì‹¤í–‰ ì „,í›„ì˜ ì„±ê²©ì„ ì •ì˜ / ëŒ€ë¶€ë¶„ì˜ ê²½ìš° í•¨ìˆ˜ì˜ ì‹¤í–‰ì¡°ê±´ì„ ì •ì˜í•˜ëŠ”ë° ì‚¬ìš©ë¨

```
contract Ballot {
    constructor() public { chairperson = msg.sender; }
    address chairperson;
    modifier onlyChair {
        require(msg.sender == chairperson, "only the chairperson can call this function");
        -;
    }
    function giveRightToVote(address to) public onlyChair {
        //'onlyChair' modifier ensures that this function is called by the chairperson
    }
}
```

4. Events

- ì´ë²¤íŠ¸ëŠ” EVMë¡œê¹…ì„ í™œìš©í•œ ì‹œìŠ¤í…œ
  - ì´ë²¤íŠ¸ê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ íŠ¸ëœì­ì…˜ ë¡œê·¸ì— ì €ì¥, ì €ì¥ëœ ë¡œê·¸ëŠ” ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œì™€ ì—°ë™ë˜ì–´ í´ë¼ì´ì–¸íŠ¸ê°€ RPCë¡œ ì¡°íšŒê°€ëŠ¥

<Contract>
```
contract Ballot {
    event Voted (address voter, uint proposal);
    function vote(uint proposal) public {
        emit Voted(msg.sender, proposal);
    }
}
```
<Client using caver-js>
```
const BallotContract = new caver.klay.Contract(abi, address);
BallotContract.events.Voted( 
    { fromBlock: 0 }, 
    function(error, event) {
    console.log(event);
    } 
).on('error', console.error);
```

5. Struct Types

- Solidityì—ì„œ ì œê³µí•˜ì§€ ì•ŠëŠ” ìƒˆë¡œìš´í˜•ì‹ì˜ ìë£Œë¥¼ ë§Œë“¤ ë•Œ ì‚¬ìš©
- ì—¬ëŸ¬ ìë£Œë¥¼ ë¬¶ì–´ ë³µì¡í•œ ìë£Œí˜•ì„ ë§Œë“¤ë•Œ ìœ ìš©

```
contract Ballot{
    struct Voter{
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
```

```
contract SocialMedia{
    struct Friend{
        uint id;
        mapping (uint => address) friends;
    }
}
```

6. Enum Types

- ì„ì˜ì˜ ìƒìˆ˜ë¥¼ ì •ì˜í•˜ê¸°ì— ì í•©
- ìƒíƒœ = Active, Inactive
- ìš”ì¼ = Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday

```
contract Ballot{
    enum Status{
        Open,
        Closed
    }
}
```

<hr />

## ìë£Œí˜•(Data Types)

- Booleans
- Integers (int,int8,...,uint256,uint,...)
- address
- Fixed-size byte arrays
- Reference Types
- Arrays
- Mapping Types
- Contract Types

1. Address = ì–´ì¹´ìš´íŠ¸ ì£¼ì†Œë¥¼ í‘œí˜„

- Klaytnì£¼ì†Œì˜ ê¸¸ì´ëŠ” 20ë°”ì´íŠ¸ : addess => byte20 í˜•ë³€í™˜ê°€ëŠ¥
- address vs address payable
  - address payable => address (ê°€ëŠ¥)
  - address => address payable (ë¶ˆê°€ëŠ¥) : uint160ì„ ê±°ì³ì„œë§Œ ê°€ëŠ¥

2. Reference Types

- Reference Typesë°ì´í„°ëŠ” ì €ì¥ë˜ëŠ” ìœ„ì¹˜ë¥¼ ë°˜ë“œì‹œ ëª…ì‹œ
  - memory (í•¨ìˆ˜ë‚´ì—ì„œ ìœ íš¨í•œ ì˜ì—­ì— ì €ì¥)
  - storage (state variablesì™€ ê°™ì´ ì˜ì†ì ìœ¼ë¡œ ì €ì¥ë˜ëŠ” ì˜ì—­ì— ì €ì¥)
  - calldata (external í•¨ìˆ˜ì¸ìì— ì‚¬ìš©ë˜ëŠ” ê³µê°„)
- ì„œë¡œ ë‹¤ë¥¸ì˜ì—­ì„ ì°¸ì¡°í•˜ëŠ” ë³€ìˆ˜ ê°„ ëŒ€ì…ì´ ë°œìƒ ì‹œ ë°ì´í„° ë³µì‚¬
  - storage => memory/calldata
  - anything => storage

3. Arrays

- JSì—ì„œ ë°°ìš´ ë°°ì—´ê³¼ ê°œë…ì€ ê°™ìœ¼ë‚˜ ì‚¬ìš©ë²•ì´ ìƒì´
  - state variableë¡œ ì‚¬ìš©í•  ë•Œ (ì €ì¥ê³µê°„ = storage)
    - `T[k] x;` = kê°œì˜ Të¥¼ ê°€ì§„ ë°°ì—´ xë¥¼ ì„ ì–¸
    - `uint[5] arr;` = arrì€ 5ê°œì˜ uintë¥¼ ê°€ì§„ ë°°ì—´ : arr[0]ì´ ì²«ë²ˆì§¸ uint
    - `T[] x;` = xëŠ” Të¥¼ ë‹´ì„ ìˆ˜ ìˆëŠ” ë°°ì—´, xì˜ í¬ê¸°ëŠ” ë³€í•  ìˆ˜ ìˆìŒ(dynamicsize)
    - `T[][k] x;` = kê°œì˜ Të¥¼ ë‹´ì„ ìˆ˜ ìˆëŠ” dynamicsize ë°°ì—´ xë¥¼ ì„ ì–¸
    - T[][k] xê°€ ì£¼ì–´ì§ˆë•Œ, x[i][j]ëŠ” (i-1)ë²ˆì§¸ ë°°ì—´ì˜ (j-1)ë²ˆì¨° Të¥¼ ë¶ˆëŸ¬ì˜´
- ëª¨ë“  ìœ í˜•ì˜ ë°ì´í„°ë¥¼ ë°°ì—´ì— ë‹´ì„ ìˆ˜ ìˆìŒ(mapping, structí¬í•¨)
- .push(T item) and .length
  - `.push(T item)`ì€ ë°°ì—´ì— ë°ì´í„°ë¥¼ ì¶”ê°€
  - `.length`ëŠ” ë°°ì—´ì˜ í¬ê¸°ë¥¼ ë°˜í™˜
- ëŸ°íƒ€ì„ì— ìƒì„±ë˜ëŠ” (í•¨ìˆ˜ë‚´ì—ì„œ)memoryë°°ì—´ì€ newí‚¤ì›Œë“œë¥¼ ì¨ì„œ ì„ ì–¸ (=ì‚¬ì´ì¦ˆë¥¼ ì§€ì •í•´ì¤˜ì•¼í•œë‹¤)
  - storageë°°ì—´ê³¼ëŠ” ë‹¬ë¦¬ memoryë°°ì—´ì€ dynamic arrayì‚¬ìš©ì´ ë¶ˆê°€

```
contract c {
    function f(uint len) public pure {
        bytes memory b = new bytes(len);
        assert(b.length == len);
    }
}
```

4. bytesN vs bytes/string vs byte[]

- (ê°€ëŠ¥í•˜ë©´)ì–¸ì œë‚˜ bytesë¥¼ ì‚¬ìš©
- byte[]ëŠ” ë°°ì—´ ì•„ì´í…œ ê°„ 31ë°”ì´íŠ¸ íŒ¨ë”©ì´ ì¶”ê°€ë¨
- ê¸°ë³¸ ë£°
  - ì„ì˜ì˜ ê¸¸ì´ì˜ ë°”ì´íŠ¸ ë°ì´í„°ë¥¼ ë‹´ì„ ë•Œ : bytes
  - ì„ì˜ì˜ ê¸¸ì´ì˜ ë°ì´í„°ê°€ UTF-8ê³¼ ê°™ì´ ë¬¸ìë¡œ ì¸ì½”ë”© ë  ìˆ˜ ìˆì„ ë•Œ : string
  - ë°”ì´íŠ¸ ë°ì´í„°ì˜ ê¸¸ì´ê°€ ì •í•´ì ¸ ìˆì„ ë•ŒëŠ” value typeì˜ bytes1,...,bytes32ë¥¼ ì‚¬ìš©
  - byte[]ëŠ” ì§€ì–‘

5. Mapping Types
   `mapping (K => V) table;`

- í•´ì‹œí…Œì´ë¸”ê³¼ ìœ ì‚¬, ë°°ì—´ì²˜ëŸ¼ ì‚¬ìš©
  - storageì˜ì—­ì—ë§Œ ì €ì¥ê°€ëŠ¥ (state variableë¡œë§Œ ì„ ì–¸ê°€ëŠ¥)
  - í•¨ìˆ˜ì¸ì, ë˜ëŠ” publicë¦¬í„´ê°’ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ

```
contract MappingExample {
    mapping(address => uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}
```

<hr />

## Special Variables and Functions

1. Block and Transaction Propertiesâ­ï¸â­ï¸â­ï¸

- `blockhash(uint blocknumber) returns (bytes32)` : ë¸”ë¡í•´ì‹œ(ìµœê·¼ 256ë¸”ë¡ê¹Œì§€ë§Œ ì¡°íšŒê°€ëŠ¥)
- `block.number (uint)` : í˜„ì¬ ë¸”ë¡ ë²ˆí˜¸
- `block.timestamp (uint)` : í˜„ì¬ ë¸”ë¡ íƒ€ì„ìŠ¤íƒ¬í”„
- `gasleft() returns (uint256)` : ë‚¨ì€ ê°€ìŠ¤ëŸ‰
- `msg.data (bytes calldata)` : ë©”ì„¸ì§€(í˜„ì¬ íŠ¸ëœì­ì…˜)ì— í¬í•¨ëœ ì‹¤í–‰ ë°ì´í„° (input)
- `msg.sender (address payable)` : í˜„ì¬ í•¨ìˆ˜ ì‹¤í–‰ì£¼ì²´ì˜ ì£¼ì†Œ
- `msg.sig (bytes4)` : calldataì˜ ì²« 4ë°”ì´íŠ¸ (í•¨ìˆ˜ í•´ì‹œ)
- `msg.value (uint)` : ë©”ì„¸ì§€ì™€ ì „ë‹¬ëœ KLAY(pebë‹¨ìœ„) ì–‘
- `now (uint)`=`block.timestemp` ì™€ ë™ì¼
- `tx.gasprice (uint)` : íŠ¸ëœì­ì…˜ gasprice (25stonìœ¼ë¡œ í•­ìƒ ë™ì¼)
- `tx.origin (address payable)` : íŠ¸ëœì­ì…˜ ì£¼ì²´ (sender)

ì»¨íŠ¸ë™íŠ¸ëŠ” ê°„ê²°í•˜ê³  ì§§ê²Œ ì‘ì„±í•´ì•¼í•˜ë¯€ë¡œ ê°€ê¸‰ì ì´ë©´ ë‚¨ì€ ê°€ìŠ¤ëŸ‰ì„ ì²´í¬í•˜ëŠ” ì½”ë“œëŠ” ì—†ëŠ”ê²ƒì´ ì¢‹ìŒ

2. Error Handling

- assert (bool condition) = conditionì´ falseì¼ ê²½ìš°, ì‹¤í–‰ì¤‘ì¸ í•¨ìˆ˜ê°€ ë³€ê²½í•œ ë‚´ì—´ì„ ëª¨ë‘ ì´ì „ ìƒíƒœë¡œ ë˜ëŒë¦¼(ë¡œì§ì²´í¬ì— ì‚¬ìš©)
- require(bool condition) = conditionì´ falseì¼ ê²½ìš°, ì‹¤í–‰ì¤‘ì¸ í•¨ìˆ˜ê°€ ë³€ê²½í•œ ë‚´ì—´ì„ ëª¨ë‘ ì´ì „ ìƒíƒœë¡œ ë˜ëŒë¦¼(ì™¸ë¶€ ë³€ìˆ˜ê²€ì¦ì— ì‚¬ìš©)
- require(bool condition, string memory message) = require(bool)ê³¼ ë™ì¼, ì¶”ê°€ë¡œ ë©”ì„¸ì§€ë¥¼ ì „ë‹¬

3. Cryptographic Function

- keccak256(bytes memory input) returns (bytes32) = ì£¼ì–´ì§„ ê°’ìœ¼ë¡œ keccak256í•´ì‹œë¥¼ ìƒì„±
- sha256(bytes memory input) returns (bytes32) = ì£¼ì–´ì§„ ê°’ìœ¼ë¡œ sha256í•´ì‹œë¥¼ ìƒì„±
- ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes s) returns (address) = ì„œëª…(v,r,s)ë¡œë¶€í„° ì–´ì¹´ìš´íŠ¸ ì£¼ì†Œë¥¼ ë„ì¶œ (ì„œëª… => ê³µê°œí‚¤ => ì£¼ì†Œ)

ğŸ”¥ê°€ìŠ¤ë¹„ë¥¼ ë§ì´ ì†Œìš”í•˜ëŠ” 3ëŒ€ì¥ -> ì¦‰, ì•ˆì“°ëŠ”ê²Œ ê°€ì¥ ì¢‹ìŒ!! ì“°ë”ë¼ë„ ë°”ê¹¥ì—ì„œ ì“°ê³  ê·¸ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ê²ƒì´ ì œì¼ ìŒˆ

<hr />

## Expressions and Control Structure

1. Solidity ì œì–´êµ¬ë¬¸

- ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ê°€ ì§€ì›í•˜ëŠ” ì œì–´êµ¬ë¬¸ì„ ì§€ì›
- if,else,while,do,for,break,continue,return

<forë¬¸>

```
function loop(uint repeat)
public pure returns (uint) {
    uint sum = 0;
    for (uint i = 0; i < repeat; i++) {
        sum += 1;
    }
    return sum;
}
```

```
function fib(uint n) public pure returns (uint) {
uint x = 0;
uint y = 1;
uint ret = 0;
for(uint i = 0; i < n; i++) {
    ret = x + y;
    x = y;
    y = ret;
    }
    return ret;
}
```

<whileë¬¸>

```
function whuleloop(uint repeat) public pure returns (uint) {
    uint sum = 0; uint i = 0;
    while (i < repeat) {
        sum += i;
        i++;
    }
    return sum;
}
```

2. â­ï¸ì˜ˆì™¸ì²˜ë¦¬ê¸°ëŠ¥ì´ ì—†ìŒ

- try-catchì—†ìŒ

<hr />

## Contracts

1. Creating contracts
   ì¼ë°˜ì ì¸ ì»¨íŠ¸ë™íŠ¸ ìƒì„± = ë°°í¬
   ì»¨íŠ¸ë™íŠ¸ë¥¼ í´ë˜ìŠ¤ì²˜ëŸ¼ ì‚¬ìš©

- ì»¨íŠ¸ë™íŠ¸ë¥¼ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì—ì„œ ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤ë¡œ ì·¨ê¸‰í•  ìˆ˜ ìˆìŒ
- newí‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì»¨íŠ¸ë™íŠ¸ë¥¼ ìƒì„±í•˜ì—¬ ë³€ìˆ˜ì— ëŒ€ì…

```
contract A {
    B b;
    constructor() public {
        b = new B(10);
    }
    function bar(uint x) public view returns (uint) {
        return b.foo(x);
    }
}
```

```
contract B {
    uint base;
    constructor(uint _base) public {
        base = _base;
    }
    function foo(uint y) public view returns (uint) {
        return y * base;
    }
}
```

2. Visibility and Getters
   í•¨ìˆ˜ì˜ Visibility(ê³µê°œì •ë„)ë¥¼ ëª©ì ì— ë§ê²Œ ì„¤ì •

- external : ë‹¤ë¥¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ&íŠ¸ëœì­ì…˜ì„ í†µí•´ í˜¸ì¶œ ê°€ëŠ¥, internalí˜¸ì¶œë¶ˆê°€ëŠ¥(`f()`ëŠ” ì•ˆë˜ì§€ë§Œ `this.f()`ëŠ” í—ˆìš©ë¨)
- public : íŠ¸ëœì­ì…˜ì„ í†µí•´ í˜¸ì¶œê°€ëŠ¥, internalí˜¸ì¶œê°€ëŠ¥

- internal : ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ë¶ˆê°€ëŠ¥, internalí˜¸ì¶œê°€ëŠ¥, ìƒì†ë°›ì€ ì»¨íŠ¸ë™íŠ¸ì—ì„œ í˜¸ì¶œê°€ëŠ¥
- private : internalí˜¸ì¶œê°€ëŠ¥

3. Function Modifiers

4. Constant State Variables
5. Functions: view, pure, fallback
   í•¨ìˆ˜ì˜ ì œì•½ì„ ì„¤ì •í•˜ì—¬ ì •í•´ì§„ scopeì—ì„œ ë™ì‘í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •

- pure : state variableì ‘ê·¼ ë¶ˆê°€ (READ (X), WRITE (X))
- view : state variableë³€ê²½ ë¶ˆê°€ (READ (O), WRITE (X))
- (none) : ì œì•½ì—†ìŒ (READ (O), WRITE (O))

- Fallback function
  - ì»¨íŠ¸ë™íŠ¸ì— ì¼ì¹˜í•˜ëŠ” í•¨ìˆ˜ê°€ ì—†ì„ ê²½ìš° ì‹¤í–‰ (no input/calldata)
    - ë‹¨ í•˜ë‚˜ë§Œ ì •ì˜ê°€ëŠ¥ & í•¨ìˆ˜ëª…, í•¨ìˆ˜ì¸ì, ë°˜í™˜ê°’ ì—†ìŒ
    - ë°˜ë“œì‹œ externalë¡œ ì„ ì–¸
  - ì»¨íŠ¸ë™íŠ¸ê°€ KLAYë¥¼ ë°›ìœ¼ë ¤ë©´ payable fallback functionì´ í•„ìš” - payable fallbackì´ ì—†ëŠ” ì»¨íŠ¸ë™íŠ¸ê°€ KLAYë¥¼ ì „ì†¡ë°›ìœ¼ë©´ ì˜¤ë¥˜ë°œìƒ

ê¸°ë³¸ì ìœ¼ë¡œ ì»¨íŠ¸ë™íŠ¸ëŠ” ëˆì„ ëª»ë°›ì§€ë§Œ ì»¨íŠ¸ë™íŠ¸ì— ëˆì„ ë³´ë‚´ëŠ” ê²½ìš°ê°€ ìˆìŒ(=Escrowí• ë•Œ) ~> payable fallbackìœ¼ë¡œë§Œë“¤ë©´ ëˆì„ ë°›ì„ ìˆ˜ ìˆë‹¤.

```
contract Escrow {
    event Deposited(address sender, uint amount);
    function() external payable {
        emit Deposited(msg.sender, msg.value);
    }
}
```
