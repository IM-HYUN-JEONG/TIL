## 블록체인

= 정보를 블록이라고 하는 단위로 저장하여 저장된 블록들을 체인 형태로 묶은 저장기술

- 블록들은 서로 체인으로 연결 (like 링크드 리스트지만, 해시함수를 이용하여 기억하는 방법이 조금 다름)
- 첫번째 블록 : Genesis Block
- 데이터들은 일정한 순서로 정렬되어 묶음으로 저장됨

## 해시함수 (Hash Function)

- 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
- { 해시, 해시값, 해시코드 } = 해시함수에 의해 얻어지는 값
- 데이터를 X, 해시함수를 H라고 표기할 때 해시를 H(X)라고 표기
- 산업에서 가장 널리 쓰이는 해시함수는 SHA-2(e.g., SHA-256), SHA-3(e.g., Keccak)

### 해시함수의 규칙

- 하나의 데이터에서 오직 단 하나의 해시가 도출, 임의의 데이터X와 Y가 있을때

  - if X == Y then H(X) == H(Y)
  - if X != Y then H(X) != H(Y)
  - if H(X) == H(Y) then X == Y

- 같은 함수라도 다른 데이터를 해시할 경우 결과값이 크게 달라진다

<hr />

## 블록체인의 구조

- 블록은 header(정보=바디의 설명)와 body(정보의 묶음)로 구분
- header = _블록을 설명하는 정보와 이전 블록의 해시를 포함_
- 이전 블록의 해시(hash pointer)를 가지기 때문에 어떤 블록이 앞에 와야하는지 결정적으로 알 수 있고, 이를 바탕으로 블록의 순서를 결정할 수 있다.

## 블록 높이, 블록 생성주기

- 블록 생성방향 = 수직(아래에서 위)으로 쌓는 방향이다.

- 블록들이 이전 블록이 아래에 최근 블록이 위로 오도록 정렬하면 블록이 생성됨에 따라 체인의 높이가 늘어난다.
- 블록의 순서를 그 블록이 위피한 높이(block height)라 부른다. 첫번쨰 블록은 편의상 높이를 0이라 함
- 다음 블록을 생성하기까지는 걸리는 시간을 *블록생성시간*이라하고 블록생성시간이 비교적 일정한 경우 *블록생성주기*란 표현을 사용
- 비트코인은 10분, 이더리움은 15초, 클레이튼은 1초

<hr />

## 블록체인 네트워크, 노드

- 기본적으로 [p2p네트워크(peer-to-peer network)](https://ko.wikipedia.org/wiki/P2P)
- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리
- 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지
- 모든 노드는 같은데이터를 가지고 있다.

## 합의(Consensus)

- 자격이 있는 참여자는 블록을 제안(propose)할 수 있음
- 블록 제안자격은 네트워크마다 상이(Proof of Work=작업증명시스템 : 어려운퍼즐을 풀은 사람이 블록제안자격을 가짐\_비트코인이 처음 씀)
- 노드들은 제안자가 올바른 자격을 취득했는지, 제안된 블록이 올바른지 검증한 뒤 블록을 자신의 체인에 추가
- 정족수 또는 정해진 기준을 만족하는 수의 노드가 블록을 자신의 체인에 추가하면 합의가 이루어졌다고 판단

## [정리] 블록체인의 성질

- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리
- 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지
- 자격이 있는 참여자는 블록을 제안할 수 있음: 블록 제안 자격은 네트워크마다 상이
- 블록이 체인에 추가됨 = 참여자들이 새 블록을 자신의 체인에 추가
- 따라서 새로운 블록이 체인에 추가되려면 네트워크의 합의가 필요 : 합의방법은 네트워크마다 상이
  - 어느 한 주체가 단독으로 결정하는 구조가 아닌, 여러 참여자가 합의를 통해 결정하기 때문에 블록체인은 탈중앙화되어 있다고 표현
- 참여자 전원은 이전 블록들을 저장하고 있으므로 새로운 블록의 무결성을 확인가능
- 새롭게 제안되는 블록은 참여자들이 검증 및 합의할 수 있는 형태여야 함(투명성)
- 한번 쓰여진 블록은 이전의 합의를 번복할 수 있지 않는 한 변경 되기 힘들다.(불변성)

<hr />

## 합의 알고리즘

- PoW = 계산이 어려운 문제를 풀 것 / 전체 연산량의 51%를 한 참여자가 소유할 경우 중앙화됨
  - 장점 : 누구나 참여할 수 있게만듦 => 네트워크를 비동기화 상태에 두어도 합의를 이끌어낼 수 있음
  - 단점 : 연산에 쓰는 비용이 비싸다
  - Bitcoin, Litecoin, Ethereum, Monero, QTUM
- PoS = 플랫폼 토큰을 보유한 양과 기간에 따라 결정적으로 또는 확률적으로 뽑힐 것 / 전체 연산량의 51%를 한 참여자가 소유할 경우 중앙화됨
  - Ethereum FFG&CFG, EOS(dPoS)
- BFT-variants = 정해진 순번 또는 확률에 의해 뽑힐 것 / 전체 참여노드의 1/3이상이 담합할 경우 합의불가, 전체 참여노드의 2/3이상이 담합할 경우 중앙화됨
  - 네트워크가 동기화 되어있음 => 네트워크에 참여한 사람이 누군지 알고, 바뀌지않음 = 누구든지 참여가 불가능
  - 합의를 이루기위해 통신이 많음 (참여자가 많을수록 느려짐)
  - Klaytn, Tendermint, Hyperledger, Fabric, Ontology

<hr />

## 블록체인의 비교 - Public vs Private

- 퍼블릭과 프라이빗의 구분은 블록체인에 다음을 수행할 수 있는지 확인하여 결정
  - 누구든지 기록된 정보(블록)를 자유롭게 읽을 수 있는지?
  - 명시적인 등록 또는 자격취득 없이 정보를 블록체인 네트워크에 기록할 수 있는지?
- 블록체인의 정보가 공개되어있고 네트워크가 정한 기준(gas fee)에 따라 정보를 기록요청할 수 있다면 그 블록체인은 퍼블릭/공개형이라고 한다.
- 이와 반대로 정보가 공개되어있지 않고 미리 자격을 득한 사용자만이 정보를 기록할 수 있다면 그 블록체인은 프라이빗/비공개형 이라 한다.

## 블록체인의 비교 - Permissionless vs Permissioned

- 일반적으로 네트워크의 참여가 제한된 경우 "Permissioned", 그렇지 않은 경우 "Permissionless"라 정의
- 네트워크의 참여의 정의
  - (넓은 의미) 블록체인 P2P네트워크에 참여
  - (좁은 의미) 합의과정의 참여
- Public/Private의 개념이 정보의 접근성(Access)와 관련이 있다면 Permissionless/Permissioned는 정보의 제어(Control) 즉 무엇이 블록에 포함되는지를 결정하는 지에 더 밀접한 개념

- Klaytn은 정보는 공개되어있지만(=public), 합의는 정해진 노드들만 참여할 수 있다(=Permissioned)

<hr />

## 공개키 암호화와 전자서명

- 고전적인 함호 : 카이사르 암호

- 대칭키 암호/비대칭키 함호

  - 평문(Plain Text) : 암호화 되어 있지 않은 문자열
  - 암호화 : 평문을 암호로 만드는 것 (cipher, encrypt)
  - 복호화 : 암호를 평문으로 만드는 것 (dechipher, decypt)
  - 대칭키 암호 : 암호화에 사용한 키와 복호화에 사용한 키가 동일한 경우
  - 비대칭키 암호 : 암호화에 사용한 키와 복호화에 사용한 키가 다를 경우

- 전자서명
  - 비대칭키 암호는 지정된 사람만 정보를 확인할 수 있도록 도움(privacy)
    - A가 B에게 메세지를 보낼 때 PKb을 사용
    - B는 이 메세지가 A에서 온 것인지 어떻게 확인할까?
  - _전자서명은 누가 정보를 보냈는지 알기 위해 사용(non-repudiation)_
    - 전자서명은 비대칭암호의 응용 프로그램
    - 서명은 비밀키로만 생성가능
    - 공개키는 서명이 짝을 이루는 비밀키로 생성되었는지를 검증

<hr />

## 블록체인에서 사용되는 암호화 기법

- 블록체인과 공개키암호

  - 블록체인은 암호화적 기법을 토대로 만들어진 기술
  - Bitcoin은 네트워크 참여자 모두가 같은 원장을 공유함으로써 투명한 거래 가능
  - 원장은 어느 주소에 BTC가 있는지 기록하지만, 그 주소가 누구에게 속하는지는 기록하지 않음(annoymity)
  - Bitcoin은 공개키암호를 사용하여 명시적인 비밀교환과정없이 BTC의 소유권 증명을 실행

- 공개키암호화를 사용한 소유권 증명
  - 대부분의 블록체인 주소는 공개키로부터 도출된 값
    - Bitcoin : Hash 160 of a public key where Hash 160 = RIPEMD160 + SHA256
    - Ethereum : Rightmost 160 bits of Keccak hash of a public key
  - Bitcoin : 임의의 주소X에 10BTC이 있다고 가정, A는 X에서 또 다른 임의의 주소 Y로 5BTC 전송하는(transfer 5BTC from X to Y)하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 한다.
  - Ethereum : 임의의 주소X에 위치한 어카운트의 잔고에 10ETH이 있다고 가정, A는 X에서 또 다른 임의의 주소 Y에 위치한 어카운트로 5ETH 전송하는(transfer 5ETH from the account at X to the account at Y)하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 한다.

<hr />

## 구현방법으로 나눈 블록체인

### UTXO(Unspent Transaction Outputs) 기반 블록체인

- 코인이 담겨있는 주소, 즉 돈에다가 주소를 줌, 돈 자체가 암호화되어있고 돈을 쓸때 전자서명
- 블록체인에 사용가능한 토큰 (bitcoin) - UTXO들과 사용 자격검증방법을 기록
- 일반적인 자격검증방법은 UTXO의 정보와 일치하는 공개키로 검증가능한 전자서명을 제출하는 것
- Bitcoin이 대표적인 UTXO기반 블록체인

### 어카운트기반 블록체인 (Account-Based)

- 어느 어카운트의 밸런스, 즉 어카운트가 밸런스라는 상태값을 가짐, 어카운트를 사용할때 전자서명
- 어카운트는 블록체인을 구성하는 주체(entity)를 표현하여 상태를 기록
- 사용자는 어카운트를 사용할 때마다 어카운트 공개키로 검증가능한 전자서명을 생성
- ⭐️상태를 기록할 수 있기 때문에, 스마트 컨트랙트를 구현하기에 용이
- Ethereum, Klaytn이 대표적인 어카운트 기반 블록체인

### Ethereum어카운트, 주소, 상태

- Ethereum어카운트는 Ethereum의 주체를 표현하고 그 상태를 기록하는데 사용
- 어카운트는 EOA와 스마트컨트랙트로 구분
- Ethereum 사용자는 EOA를 사용
- 사용자는 임의의 공개키와 비밀키 쌍을 생성한 뒤 공개키를 어카운트 주소로 변환하여 EOA생성
  - 별도의 승인과정이 필요없으며 Ethereum네트워크와 통신도 필요없음
  - 위 과정으로 인해 어카운트는 특정 키페어에 종속
- 사용자의 상태는 어카운트 주소로 찾을 수 있는 블록체인 저장공간에 기록

  <hr />

## 트랜잭션 (TX)

- 블록은 트랜잭션들을 일정한 순서로 정렬하여 저장하는 컨테이너
- 트랜잭션은 어카운트의 행동
- 트랜잭션의 순서는 중요 : TX_1 -> TX_2 와 TX_2 -> TX_1는 다름
- 블록체인 참여자들은 블록을 검증할 때 트랜잭션들이 올바른 순서대로 정렬되었는지를 확인 후 합의
- 각각의 트랜잭션들은 어카운트에 연결된 공개키로 검증가능한 서명을 포함
- 트랜잭션들은 일정한 순서로 정렬되어 묶음으로 저장

<hr />

## Confirmation vs Finality

- Confirmation 숫자는 트랜잭션이 블록에 포함된 이후 생성된 블록의 숫자
  - 임의의 트랜잭션 T가 포함된 블록의 높이가 100, 현재 블록의 높이가 105라면 T의 Confirmation 숫자는 6
- PoW를 사용하는 블록체인들은 Finality가 없기 때문에 Confirmation숫자가 중요
- Finality란 블록의 완결성을 의미
  - 합의를 통해 생성된 블록이 번복되지 않을 경우 완결성이 존재
- PoW기반 합의는 확률에 기반하기 때문에 경우에 따라 블록이 사라질 수 있으므로 완결성이 부재
  - PoW블록체인은 수학적으로 복잡한 퍼즐을 풀어 블록을 제안할 자격을 얻는 구조
  - 만약 두명의 서로 다른 참여자가 동시에 퍼즐을 풀어 두개의 올바른 블록을 생성한다면 두 블록 중 하나는 eventually 사라지게 됨 (longest chain이 살아남기에)
  - 이 떄문에 블록이 확률적 완결성을 갖기까지 일정 갯수 이상의 블록이 생성되기를 기다려야 함

## Understanding Bitcoin's 6 Confirmations Rule

- 네트워크 시차로 인해 생성된 우연한 복수의 블록들 가운데 하나가 선택되는데 필요한 블록은 두어개 정도 -> 2~3confirmations
- 퍼증을 빠르게 풀 수 있는 악의적인 참여자(공격자)가 있을 경우 그 참여자의 해시능력에 따라 필요한 confirmation숫자가 달라짐
  - 해시능력이 높을수록 퍼즐을 푸는 속도도 빠르기 때문에 주어진 문제를 먼저 풀 확률이 높아짐
  - 해시능력이 높은 참여자는 longest chain을 임의로 선택 또는 생성할 수 있음
  - 따라서 해시능력은 감안하더라도 임의의 블록체인을 변경하지 못할 정도로 충분히 많은 블록이 생성되기를 기다려야 할 필요가 생김
  - Bitcoin's 6 Confirmations Rule은 공격자가 전체 해시능력의 약 25%를 가질 때를 가정한 숫자

## BFT기반 블록체인

- BFT기반 블록체인은 블록의 완결성이 보장됨
  - 네트워크가 동기화되어있기 때문
  - 블록생성이 PoW에 비해 빠르고 경제적
- 하지만, 네트워크 동기화의 필요로 인해 참여자의 숫자가 제한
  - 네트워크 참여자 구성이 고정되어 있어야 합의가능
  - 구성이 변경될 경우 모든 네트워크 참여자가 새로운 구성을 인지하기까지 합의 불가능
  - 합의 알고리즘이 네트워크 동기화를 가정하고 짜여졌기 때문에 네트워크 사용량이 높음
  - 참여자가 많아질 경우 네트워크 오버헤드로 인해 합의가 느림
